0-1背包问题

1. 先将问题转成01背包，找出要求的容量，物品的价值和重量，其本质就是
   对于每一个容量j，都有我现在有这么大的容量，有这些东西，你就看看你能装多少吧，能装就装，不能装就拉倒

2. 确定dp数组和含义，分成两种
   1) 如果是确定最大价值的，则dp[j] 表示 在容量为j的前提下，从[0 ... i]之间挑选物品，这些物品的最大价值就是dp[j]
   2) 如果是确定组合数，则dp[j] 表示 在容量为j的前提下，在[0 ... i]之间挑选物品，这些物品重量之和恰好是j的所有组合个数

3. 确定状态转移方程
   1) 如果不求组合数，那么转移方程是 dp[j] = max( dp[j], dp[j - weight[i]] + values[i]) 的变种，根据题目变化
      可能是weights数组和values数组是一个数字，也可能不存在values数组，value是一个常数或者其他
   2) 如果求组合数，那么转移方程就应该是 dp[j] += dp[ j - weight[i]]

4. 初始化  很重要！！！！！！！！！！！！！！！！！！！！！！！！！！！！
   有可能只初始化dp[0]为0或者1，也有可能需要将整个dp数组都初始化为1，根据题目而定
   对于容量为0的情况下初始为0还是1，根据确定的状态转移方程确定，如果0的时候状态转移成功就用0，如果初始为导致后续
   都为0，那就试试1。如果还不行，根据题意来定。
   对于求最小和最大的问题，如果有必要的话，试着反向初始化，即求最小，那么初始化一个最大值，在遍历的时候小于这个值就更新
   求最大，初始化一个最小值...（CoinChange就是个典型例子）

5. 遍历顺序
   在01背包问题下，外层for循环都是从左到右，内层for循环都是从右到左。先遍历物品还是先遍历容量无所谓，但是一般先遍历
   物品，因为比较好理解。
   关于循环的起始条件和终止条件，外层如果是遍历物品，一般就是从0开始到最后一个。内层因为是遍历容量且逆序，所以一般从
   最大容量开始，遍历到容量小于当前物品重量为止，因为如果容量小于当前物品重量，那么继续遍历就没有意义了，因为根本装不下
   也即 for (capacity; capacity >= weight[i]; capacity--)

   对于多维度dp，如OnesAndZeros题，各个维度之间的遍历是嵌套关系，不是并列关系，遍历顺序一般不重要（试题目而定）



完全背包问题

1. 思路和01相同，不同之处在于遍历顺序
   01背包内层从右往左遍历是为了避免重复使用i之前的物品，但是完全背包的物品使用次数是无限的
   因此在完全背包问题中，内层循环的遍历顺序也是从左向右。

2. 先遍历谁的问题
   1) 对于组合问题，外层循环先遍历物品，因为先遍历物品，每一个物品的使用次序就不可能再发生变化。
      内层从左到右遍历容量，从 capacity >= weight[i] 开始
   2) 对于排列问题，{物品1， 物品2}和{物品2， 物品1}是两种不同答案，因此在每次遍历的时候都要考虑物品顺序
      所以要先遍历容量，再遍历物品，需要加if条件判断当前容量是否能放得下该物品
      可以看CoinChange02这道题，如果先遍历容量，再遍历物品，在额度为3的时候，就有三种可能，111，12和21


总结：
对于背包问题的应用而言，动态规划五部曲：
1. 把实际问题转换成相应的背包问题（01背包还是完全背包），[也有可能是其它类型的动态规划，现在还没学]，确定weight和value数组。
2. 确定dp数组下标和含义，看是组合问题还是排列问题
3. 确定状态转移方程
    非组合：dp[j] = max( dp[j], dp[j - weight[i]] + values[i])的变种
    组合：dp[j] += dp[ j - weight[i]] 的变种
4. 初始化
5. 遍历顺序
    01背包：先物品，再重量，物品左到右，重量右到左
    完全背包：
        组合：先物品再重量，都是从左到右
        排序：先重量再物品，都是从左到右




对于最长公共子序列和子数组的dp问题

    首先，子序列是不连续的，子数组是连续的，这就造成了他们的状态转移不同。
    例如，对于 abbbb 和 babab 这两个数组，如果是子数组问题，那么结果是2，最长公共子数组是ab
        如果是子序列问题，那么结果就是abb，长度为3，因为子序列可以不连续。

    dp数组的定义都是dp[i][j] 表示 nums1[0 ... i - 1]范围和nums2[0 ... j - 1]范围内的结果
    因此dp数组要开dp[n1 + 1][n2 + 1]

    对于子序列问题，如 力扣1143（最长公共子序列）
        对于每一个元素，都存在要和不要两种可能
        1. 如果不要，那么其状态可以由nums1转换而来，也可以由nums2转换而来，因此选取这两个状态的最大值
           因此dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
        2. 只有当nums1[i - 1] == nums2[j - 1]的时候才能要这个元素
           此时的状态应该是由nums1[0 ... i - 2]和nums[0 ... j - 2]所表示的结果后面加上一个nums[i - 1]
           因此dp[i][j] = dp[i - 1][j - 1] + 1
           dp[i - 1][j - 1]代表 nums1[0 ... i - 2]和nums[0 ... j - 2] 这个范围内的结果
           1 表示 nums1[i - 1]这个元素
           记住状态的定义dp[i][j] 表示[0 ... i - 1]和[0 ... j - 1]这个范围内的结果，不包括i和j

    但是对于子数组问题，如力扣718（最长公共子数组）其状态只能由dp[i - 1][j - 1]推导而来，因为子数组必须是连续的
    只有当nums1[i - 1] == nums2[j - 1]的时候，那么dp[i][j]才能更新状态