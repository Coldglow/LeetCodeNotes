0-1背包问题

1. 先将问题转成01背包，找出要求的容量，物品的价值和重量，其本质就是
   对于每一个容量j，都有我现在有这么大的容量，有这些东西，你就看看你能装多少吧，能装就装，不能装就拉倒

2. 确定dp数组和含义，分成两种
   1) 如果是确定最大价值的，则dp[j] 表示 在容量为j的前提下，从[0 ... i]之间挑选物品，这些物品的最大价值就是dp[j]
   2) 如果是确定组合数，则dp[j] 表示 在容量为j的前提下，在[0 ... i]之间挑选物品，这些物品重量之和恰好是j的所有组合个数

3. 确定状态转移方程
   1) 如果不求组合数，那么转移方程是 dp[j] = max( dp[j], dp[j - weight[i]] + values[i]) 的变种，根据题目变化
      可能是weights数组和values数组是一个数字，也可能不存在values数组，value是一个常数或者其他
   2) 如果求组合数，那么转移方程就应该是 dp[j] += dp[ j - weight[i]]

4. 初始化  很重要！！！！！！！！！！！！！！！！！！！！！！！！！！！！
   有可能只初始化dp[0]为0或者1，也有可能需要将整个dp数组都初始化为1，根据题目而定
   对于容量为0的情况下初始为0还是1，根据确定的状态转移方程确定，如果0的时候状态转移成功就用0，如果初始为导致后续
   都为0，那就试试1。如果还不行，根据题意来定。
   对于求最小和最大的问题，如果有必要的话，试着反向初始化，即求最小，那么初始化一个最大值，在遍历的时候小于这个值就更新
   求最大，初始化一个最小值...（CoinChange就是个典型例子）

5. 遍历顺序
   在01背包问题下，外层for循环都是从左到右，内层for循环都是从右到左。先遍历物品还是先遍历容量无所谓，但是一般先遍历
   物品，因为比较好理解。
   关于循环的起始条件和终止条件，外层如果是遍历物品，一般就是从0开始到最后一个。内层因为是遍历容量且逆序，所以一般从
   最大容量开始，遍历到容量小于当前物品重量为止，因为如果容量小于当前物品重量，那么继续遍历就没有意义了，因为根本装不下
   也即 for (capacity; capacity >= weight[i]; capacity--)

   对于多维度dp，如OnesAndZeros题，各个维度之间的遍历是嵌套关系，不是并列关系，遍历顺序一般不重要（试题目而定）



完全背包问题

1. 思路和01相同，不同之处在于遍历顺序
   01背包内层从右往左遍历是为了避免重复使用i之前的物品，但是完全背包的物品使用次数是无限的
   因此在完全背包问题中，内层循环的遍历顺序也是从左向右。

2. 先遍历谁的问题
   1) 对于组合问题，外层循环先遍历物品，因为先遍历物品，每一个物品的使用次序就不可能再发生变化。
      内存从左到右遍历容量，从 capacity >= weight[i] 开始
   2) 对于排列问题，{物品1， 物品2}和{物品2， 物品1}是两种不同答案，因此在每次遍历的时候都要考虑物品顺序
      所以要先遍历容量，再遍历物品，需要加if条件判断当前容量是否能放得下该物品
      可以看CoinChange02这道题，如果先遍历容量，再遍历物品，在额度为3的时候，就有三种可能，111，12和21


总结：
对于背包问题的应用而言，动态规划五部曲：
1. 把实际问题转换成相应的背包问题（01背包还是完全背包），[也有可能是其它类型的动态规划，现在还没学]，确定weight和value数组。
2. 确定dp数组下标和含义，看是组合问题还是排列问题
3. 确定状态转移方程
    非组合：dp[j] = max( dp[j], dp[j - weight[i]] + values[i])的变种
    组合：dp[j] += dp[ j - weight[i]] 的变种
4. 初始化
5. 遍历顺序
    01背包：先物品，再重量，物品左到右，重量右到左
    完全背包：
        组合：先物品再重量，都是从左到右
        排序：先重量再物品，都是从左到右